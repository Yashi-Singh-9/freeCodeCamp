# Stern-Brocot sequence

### Description

For this task, the Stern-Brocot sequence is to be generated by an algorithm similar to that employed in generating the [Fibonacci sequence](https://rosettacode.org/wiki/Fibonacci_sequence).

1. The first and second members of the sequence are both 1:
      - 1, 1

2. Start by considering the second member of the sequence
3. Sum the considered member of the sequence and its precedent, (1 + 1) = 2, and append it to the end of the sequence:

    - 1, 1, 2

4. Append the considered member of the sequence to the end of the sequence:
     - 1, 1, 2, 1

5. Consider the next member of the series, (the third member i.e. 2)
6. GOTO 3

  - 
  - ─── Expanding another loop we get: ───
  - 

7. Sum the considered member of the sequence and its precedent, (2 + 1) = 3, and append it to the end of the sequence:

     - 1, 1, 2, 1, 3
8. Append the considered member of the sequence to the end of the sequence:

   - 1, 1, 2, 1, 3, 2
9. Consider the next member of the series, (the fourth member i.e. 1)

---

Create a function that returns the position in the Stern-Brocot sequence at which $ n $ is first encountered, where the sequence is generated with the method outlined above. Note that this sequence uses 1 based indexing.

### Tests

1. `sternBrocot` should be a function.
2. `sternBrocot(2)` should return a number.
3. `sternBrocot(2)` should return `3`.
4. `sternBrocot(3)` should return `5`.
5. `sternBrocot(5)` should return `11`.
6. `sternBrocot(7)` should return `19`.
7. `sternBrocot(10)` should return `39`.

### Solution: 

```javascript
function sternBrocot(n) {
    // Initialize the sequence
    const sequence = [1, 1];
    let i = 1;  // Index to track the current "considered" member (1-based index)

    // Generate the sequence until we find the first occurrence of n
    while (true) {
        const current = sequence[i];
        const previous = sequence[i - 1];

        // Calculate the next term in sequence: current + previous
        const newTerm = current + previous;
        sequence.push(newTerm);
        
        // Append the current term to the end as per the rule
        sequence.push(current);
        
        // Check if n is in the sequence and return the 1-based index
        for (let j = sequence.length - 2; j < sequence.length; j++) {
            if (sequence[j] === n) {
                return j + 1;  // Convert to 1-based index
            }
        }

        // Move to the next element in the sequence
        i += 1;
    }
}

// Test cases
console.log(sternBrocot(2)); // Should return 3
console.log(sternBrocot(3)); // Should return 5
console.log(sternBrocot(5)); // Should return 11
console.log(sternBrocot(7)); // Should return 19
console.log(sternBrocot(10)); // Should return 39
```